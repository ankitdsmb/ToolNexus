@model ToolNexus.Application.Models.ToolDescriptor
@{
    var index = ViewData["CardIndex"] as int? ?? 0;
    var icon = ResolveIcon(Model.Category, Model.Slug);
    var tags = ResolveTags(Model.Actions, Model.Category);
    var usageScore = ResolveUsageScore(Model.Slug);
    var isNew = index < 2;
    var isPopular = usageScore >= 82 || index % 4 == 0;
    var badges = new List<string>();

    if (isNew)
    {
        badges.Add("New");
    }

    if (isPopular)
    {
        badges.Add("Popular");
    }

    var performanceLabel = Model.IsCpuIntensive ? "Compute-heavy" : "Edge-fast";
    var trendLabel = usageScore >= 90 ? "P99" : usageScore >= 80 ? "P95" : "P90";
}

<a class="tool-card"
   data-reveal
   href="/tools/@Model.Slug"
   data-tool-slug="@Model.Slug"
   style="--stagger-index:@index"
   aria-label="Open @Model.Title">
  <header class="tool-card__header">
    <span class="tool-card__icon" aria-hidden="true">@icon</span>

    <div class="tool-card__title-wrap">
      <h3 class="tool-card__title">@Model.Title</h3>
      <p class="tool-card__description">@Model.SeoDescription</p>
    </div>

    <span class="tool-card__arrow" aria-hidden="true">↗</span>
  </header>

  @if (badges.Count > 0)
  {
    <div class="tool-card__badges" aria-label="Tool state badges">
      @foreach (var badge in badges.Take(2))
      {
        <span class="tool-card__badge">@badge</span>
      }
    </div>
  }

  <div class="tool-card__tags" aria-label="Supported data tags">
    @foreach (var tag in tags.Take(2))
    {
      <span class="tool-card__tag">@tag</span>
    }
  </div>

  <footer class="tool-card__meta">
    <span class="tool-card__meta-item">Usage <strong data-tool-usage>@usageScore%</strong></span>
    <span class="tool-card__meta-item">@performanceLabel <strong>@trendLabel</strong></span>
  </footer>
</a>

@functions {
    private static string ResolveIcon(string category, string slug)
    {
        var key = $"{category} {slug}".ToLowerInvariant();

        if (key.Contains("json")) return "{}";
        if (key.Contains("xml") || key.Contains("html")) return "</>";
        if (key.Contains("csv") || key.Contains("table")) return "▦";
        if (key.Contains("base64") || key.Contains("encode") || key.Contains("decode")) return "⟲";

        return "⚡";
    }

    private static IReadOnlyCollection<string> ResolveTags(IReadOnlyCollection<string> actions, string category)
    {
        var tags = new List<string>();
        var hints = string.Join(' ', actions).ToLowerInvariant() + " " + category.ToLowerInvariant();

        if (hints.Contains("json")) tags.Add("JSON");
        if (hints.Contains("xml") || hints.Contains("html")) tags.Add("XML");
        if (hints.Contains("csv")) tags.Add("CSV");
        if (hints.Contains("yaml")) tags.Add("YAML");
        if (tags.Count == 0) tags.Add("Utility");

        return tags.Take(2).ToArray();
    }

    private static int ResolveUsageScore(string slug)
    {
        var hash = Math.Abs(slug.GetHashCode());
        return 58 + (hash % 38);
    }
}
