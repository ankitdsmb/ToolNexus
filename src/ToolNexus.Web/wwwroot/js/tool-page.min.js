document.addEventListener('DOMContentLoaded', () => {
const page = document.querySelector('.tool-page');

if (!page) {
  // Not on tool page. Exit safely.
  return;
}

/* --------------------------------------------------
   Configuration
-------------------------------------------------- */

const slug = page.dataset.slug ?? '';
const apiBase = page.dataset.apiBase ?? '';
const maxClientInputBytes = 1024 * 1024;

const clientSafeActions = new Set(
  (page.dataset.clientSafeActions ?? '')
    .split(',')
    .map(a => a.trim().toLowerCase())
    .filter(Boolean)
);

/* --------------------------------------------------
   DOM References
-------------------------------------------------- */

const inputTextArea = document.getElementById('inputEditor');
const outputTextArea = document.getElementById('outputEditor');
const actionSelect = document.getElementById('actionSelect');

const runBtn = document.getElementById('runBtn');
const copyBtn = document.getElementById('copyBtn');
const downloadBtn = document.getElementById('downloadBtn');
const runSpinner = document.getElementById('runSpinner');

const errorMessage = document.getElementById('errorMessage');
const resultStatus = document.getElementById('resultStatus');
const toastRegion = document.getElementById('toastRegion');

/* --------------------------------------------------
   CodeMirror Setup
-------------------------------------------------- */

const inputEditor = CodeMirror.fromTextArea(inputTextArea, {
  lineNumbers: true,
  mode: 'application/json',
  theme: 'default'
});

const outputEditor = CodeMirror.fromTextArea(outputTextArea, {
  lineNumbers: true,
  mode: 'application/json',
  readOnly: true
});

/* --------------------------------------------------
   State
-------------------------------------------------- */

let isRunning = false;

/* --------------------------------------------------
   Utilities
-------------------------------------------------- */

function sanitizeInput(input) {
  if (typeof input !== 'string') return '';
  return input.replace(/\u0000/g, '');
}

function hasInput() {
  return inputEditor.getValue().trim().length > 0;
}

function getUtf8SizeInBytes(input) {
  return new TextEncoder().encode(input).length;
}

function isEligibleForClientExecution(input) {
  return getUtf8SizeInBytes(input) <= maxClientInputBytes;
}

function setRunningState(running) {
  isRunning = running;

  if (runBtn) {
    runBtn.disabled = running;
    runBtn.setAttribute('aria-busy', running ? 'true' : 'false');
  }

  if (runSpinner) {
    runSpinner.hidden = !running;
  }

  if (resultStatus) {
    resultStatus.className = `result-indicator result-indicator--${running ? 'running' : 'idle'}`;
    resultStatus.textContent = running ? 'Running tool...' : 'Ready';
  }
}

function showError(message) {
  if (!errorMessage) return;
  errorMessage.hidden = false;
  errorMessage.textContent = message;
}

function clearError() {
  if (!errorMessage) return;
  errorMessage.hidden = true;
  errorMessage.textContent = '';
}

function showToast(message, type = 'info') {
  if (!toastRegion) return;

  const toast = document.createElement('div');
  toast.className = `toast toast--${type}`;
  toast.role = 'status';
  toast.textContent = message;

  toastRegion.appendChild(toast);

  setTimeout(() => toast.remove(), 3000);
}

/* --------------------------------------------------
   Client Executor (Hybrid Architecture)
-------------------------------------------------- */

class ClientToolExecutor {
  canExecute(toolSlug, action, input) {
    const normalizedAction = action.toLowerCase();
    if (!clientSafeActions.has(normalizedAction)) {
      return false;
    }

    if (!isEligibleForClientExecution(input)) {
      return false;
    }

    return this.isClientSafeToolAction(toolSlug, normalizedAction);
  }

  isClientSafeToolAction(toolSlug, action) {
    if (toolSlug === 'json-formatter' && (action === 'format' || action === 'minify')) {
      return true;
    }

    if (toolSlug === 'base64-tool' && (action === 'encode' || action === 'decode')) {
      return true;
    }

    return false;
  }

  async execute(toolSlug, action, input) {
    if (toolSlug === 'json-formatter') {
      return this.executeJsonFormatter(action, input);
    }

    if (toolSlug === 'base64-tool') {
      return this.executeBase64(action, input);
    }

    throw new Error('Client execution is not supported for this tool/action.');
  }

  executeJsonFormatter(action, input) {
    let parsed;
    try {
      parsed = JSON.parse(input);
    } catch {
      throw new Error('Invalid JSON input. Please fix JSON syntax and try again.');
    }

    if (action === 'format') {
      return JSON.stringify(parsed, null, 2);
    }

    if (action === 'minify') {
      return JSON.stringify(parsed);
    }

    throw new Error('Unsupported JSON action.');
  }

  executeBase64(action, input) {
    if (action === 'encode') {
      return this.base64EncodeUtf8(input);
    }

    if (action === 'decode') {
      return this.base64DecodeUtf8(input);
    }

    throw new Error('Unsupported Base64 action.');
  }

  base64EncodeUtf8(input) {
    try {
      const bytes = new TextEncoder().encode(input);
      let binary = '';

      for (let i = 0; i < bytes.length; i += 1) {
        binary += String.fromCharCode(bytes[i]);
      }

      return btoa(binary);
    } catch {
      throw new Error('Unable to Base64 encode input in the browser.');
    }
  }

  base64DecodeUtf8(input) {
    try {
      const binary = atob(input);
      const bytes = new Uint8Array(binary.length);

      for (let i = 0; i < binary.length; i += 1) {
        bytes[i] = binary.charCodeAt(i);
      }

      return new TextDecoder().decode(bytes);
    } catch {
      throw new Error('Invalid Base64 input. Please verify the encoded data.');
    }
  }
}

const clientExecutor = new ClientToolExecutor();

/* --------------------------------------------------
   API Execution
-------------------------------------------------- */

async function executeViaApi(action, input) {
  const endpoint = apiBase
    ? `${apiBase.replace(/\/$/, '')}/api/v1/tools/${encodeURIComponent(slug)}`
    : `/api/v1/tools/${encodeURIComponent(slug)}`;

  const response = await fetch(
    endpoint,
    {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ action, input })
    }
  );

  let result = null;
  try {
    result = await response.json();
  } catch {
    result = null;
  }

  if (!response.ok) {
    let message = 'Tool execution failed.';

    if (response.status === 400) {
      message = result?.error || result?.detail || 'Invalid request.';
    } else if (response.status === 404) {
      message = result?.error || 'Tool not found.';
    } else if (response.status === 500) {
      message = result?.error || result?.detail || 'Server error.';
    } else {
      message = result?.error || result?.detail ||
        `Request failed with status ${response.status}.`;
    }

    throw new Error(message);
  }

  return result?.output || result?.error || 'No output';
}

/* --------------------------------------------------
   Run Logic
-------------------------------------------------- */

async function run() {
  const selectedAction = actionSelect?.value ?? '';

  if (!slug) {
    showError('Tool configuration error.');
    return;
  }

  if (!hasInput()) {
    showError('Please provide input before running.');
    showToast('Input required.', 'warning');
    return;
  }

  clearError();

  const sanitizedInput = sanitizeInput(inputEditor.getValue());

  try {
    setRunningState(true);

    if (clientExecutor.canExecute(slug, selectedAction, sanitizedInput)) {
      try {
        const localOutput = await clientExecutor.execute(
          slug,
          selectedAction,
          sanitizedInput
        );

        outputEditor.setValue(localOutput ?? 'No output');
        showToast('Executed locally.', 'success');
        return;
      } catch (clientError) {
        const safeMessage = clientError?.message || 'Client execution failed. Falling back to server.';
        showError(safeMessage);

        if (slug === 'json-formatter' || slug === 'base64-tool') {
          showToast('Client execution failed; using server fallback.', 'warning');
        }
      }
    }

    const apiOutput = await executeViaApi(selectedAction, sanitizedInput);
    outputEditor.setValue(apiOutput);
    showToast('Execution completed.', 'success');
  } catch (error) {
    console.error('Execution error:', error);
    outputEditor.setValue(
      error?.message ||
      'Unable to run tool due to a network error.'
    );
    showToast('Execution failed.', 'error');
  } finally {
    setRunningState(false);
  }
}

/* --------------------------------------------------
   Event Listeners
-------------------------------------------------- */

runBtn?.addEventListener('click', run);

copyBtn?.addEventListener('click', async () => {
  const output = outputEditor.getValue();

  if (!output.trim()) {
    showToast('Nothing to copy.', 'warning');
    return;
  }

  try {
    await navigator.clipboard.writeText(output);
    showToast('Copied to clipboard.', 'success');
  } catch {
    showToast('Copy failed.', 'error');
  }
});

downloadBtn?.addEventListener('click', () => {
  const output = outputEditor.getValue();

  if (!output.trim()) {
    showToast('Nothing to download.', 'warning');
    return;
  }

  const blob = new Blob([output], { type: 'text/plain' });
  const anchor = document.createElement('a');
  anchor.href = URL.createObjectURL(blob);
  anchor.download = `${slug}-output.txt`;
  anchor.click();
  URL.revokeObjectURL(anchor.href);

  showToast('Download started.', 'info');
});

inputEditor.addKeyMap({
  'Ctrl-Enter': run,
  'Cmd-Enter': run
});

/* --------------------------------------------------
   Initial State
-------------------------------------------------- */

setRunningState(false);

window.ToolNexusRun = run;
});
