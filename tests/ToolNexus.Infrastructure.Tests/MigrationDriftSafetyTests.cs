using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Migrations;
using Xunit;
using Xunit.Sdk;

namespace ToolNexus.Infrastructure.Tests;

public sealed class MigrationDriftSafetyTests
{
    [Fact]
    public async Task MissingForeignKey_DriftedSchema_MigrationReplayIsSafe()
    {
        await using var database = await CreatePostgresDatabaseOrSkipAsync();
        await using var context = database.CreateContext();

        await context.Database.ExecuteSqlRawAsync("CREATE TABLE IF NOT EXISTS migration_safety_fk_parent(id integer primary key);");
        await context.Database.ExecuteSqlRawAsync("CREATE TABLE IF NOT EXISTS migration_safety_fk_child(id integer primary key, parent_id integer);");
        await context.Database.ExecuteSqlRawAsync("ALTER TABLE migration_safety_fk_child DROP CONSTRAINT IF EXISTS fk_migration_safety_fk_child_parent;");

        await context.Database.ExecuteSqlRawAsync(@"
            DO $$
            BEGIN
                IF to_regclass('migration_safety_fk_child') IS NOT NULL THEN
                    ALTER TABLE ""migration_safety_fk_child"" DROP CONSTRAINT IF EXISTS ""fk_migration_safety_fk_child_parent"";
                END IF;
            END $$;");

        await context.Database.MigrateAsync();
        Assert.Empty(await context.Database.GetPendingMigrationsAsync());
    }

    [Fact]
    public async Task MissingIndex_DriftedSchema_MigrationReplayIsSafe()
    {
        await using var database = await CreatePostgresDatabaseOrSkipAsync();
        await using var context = database.CreateContext();

        await context.Database.ExecuteSqlRawAsync("CREATE TABLE IF NOT EXISTS migration_safety_idx(id integer primary key, correlation_id text);");
        await context.Database.ExecuteSqlRawAsync("DROP INDEX IF EXISTS idx_migration_safety_missing;");
        await context.Database.ExecuteSqlRawAsync("DROP INDEX IF EXISTS \"idx_migration_safety_missing\";");

        await context.Database.MigrateAsync();
        Assert.Empty(await context.Database.GetPendingMigrationsAsync());
    }

    [Fact]
    public async Task PartialPreviousMigrationState_DriftedObjects_DoNotBlockMigration()
    {
        await using var database = await CreatePostgresDatabaseOrSkipAsync();
        await using var context = database.CreateContext();

        await context.Database.ExecuteSqlRawAsync("CREATE TABLE IF NOT EXISTS audit_outbox(id uuid primary key, audit_event_id uuid);");
        await context.Database.ExecuteSqlRawAsync("ALTER TABLE audit_outbox DROP CONSTRAINT IF EXISTS \"FK_audit_outbox_audit_events_AuditEventId\";");

        await context.Database.MigrateAsync();
        await context.Database.MigrateAsync();

        Assert.Empty(await context.Database.GetPendingMigrationsAsync());
    }


    [Fact]
    public async Task ToolUseCasesIdentityColumn_PreexistingIdentity_DoesNotFailExecutionLedgerMigration()
    {
        await using var database = await CreatePostgresDatabaseOrSkipAsync();
        await using var context = database.CreateContext();

        var migrator = context.Database.GetService<IMigrator>();

        await migrator.MigrateAsync("20260222173745_InitialContentBaseline");

        await context.Database.ExecuteSqlRawAsync("""
            DO $$
            BEGIN
                IF EXISTS (
                    SELECT 1
                    FROM information_schema.columns
                    WHERE table_schema = 'public'
                      AND table_name = 'ToolUseCases'
                      AND column_name = 'Id'
                      AND is_identity = 'NO')
                THEN
                    ALTER TABLE "ToolUseCases"
                        ALTER COLUMN "Id" ADD GENERATED BY DEFAULT AS IDENTITY;
                END IF;
            END $$;
            """);

        await migrator.MigrateAsync("20260225214033_AddExecutionLedger");
        await context.Database.MigrateAsync();

        Assert.Empty(await context.Database.GetPendingMigrationsAsync());
    }

    [Fact]
    public async Task ToolStepsIdentityColumn_PreexistingIdentity_DoesNotFailExecutionLedgerMigration()
    {
        await using var database = await CreatePostgresDatabaseOrSkipAsync();
        await using var context = database.CreateContext();

        var migrator = context.Database.GetService<IMigrator>();

        await migrator.MigrateAsync("20260222173745_InitialContentBaseline");

        await context.Database.ExecuteSqlRawAsync("""
            DO $$
            BEGIN
                IF EXISTS (
                    SELECT 1
                    FROM information_schema.columns
                    WHERE table_schema = 'public'
                      AND table_name = 'ToolSteps'
                      AND column_name = 'Id'
                      AND is_identity = 'NO')
                THEN
                    ALTER TABLE "ToolSteps"
                        ALTER COLUMN "Id" ADD GENERATED BY DEFAULT AS IDENTITY;
                END IF;
            END $$;
            """);

        await migrator.MigrateAsync("20260225214033_AddExecutionLedger");
        await context.Database.MigrateAsync();

        Assert.Empty(await context.Database.GetPendingMigrationsAsync());
    }

    [Fact]
    public async Task ToolFeaturesIdentityColumn_PreexistingIdentity_DoesNotFailExecutionLedgerMigration()
    {
        await using var database = await CreatePostgresDatabaseOrSkipAsync();
        await using var context = database.CreateContext();

        var migrator = context.Database.GetService<IMigrator>();

        await migrator.MigrateAsync("20260222173745_InitialContentBaseline");

        await context.Database.ExecuteSqlRawAsync("""
            DO $$
            BEGIN
                IF EXISTS (
                    SELECT 1
                    FROM information_schema.columns
                    WHERE table_schema = 'public'
                      AND table_name = 'ToolFeatures'
                      AND column_name = 'Id'
                      AND is_identity = 'NO')
                THEN
                    ALTER TABLE "ToolFeatures"
                        ALTER COLUMN "Id" ADD GENERATED BY DEFAULT AS IDENTITY;
                END IF;
            END $$;
            """);

        await migrator.MigrateAsync("20260225214033_AddExecutionLedger");
        await context.Database.MigrateAsync();

        Assert.Empty(await context.Database.GetPendingMigrationsAsync());
    }

    [Fact]
    public async Task ToolFaqsIdentityColumn_PreexistingIdentity_DoesNotFailExecutionLedgerMigration()
    {
        await using var database = await CreatePostgresDatabaseOrSkipAsync();
        await using var context = database.CreateContext();

        var migrator = context.Database.GetService<IMigrator>();

        await migrator.MigrateAsync("20260222173745_InitialContentBaseline");

        await context.Database.ExecuteSqlRawAsync("""
            DO $$
            BEGIN
                IF EXISTS (
                    SELECT 1
                    FROM information_schema.columns
                    WHERE table_schema = 'public'
                      AND table_name = 'ToolFaqs'
                      AND column_name = 'Id'
                      AND is_identity = 'NO')
                THEN
                    ALTER TABLE "ToolFaqs"
                        ALTER COLUMN "Id" ADD GENERATED BY DEFAULT AS IDENTITY;
                END IF;
            END $$;
            """);

        await migrator.MigrateAsync("20260225214033_AddExecutionLedger");
        await context.Database.MigrateAsync();

        Assert.Empty(await context.Database.GetPendingMigrationsAsync());
    }



    [Fact]
    public async Task ExecutionLedgerMigration_PreexistingAdminIdentityUsersTable_DoesNotFail()
    {
        await using var database = await CreatePostgresDatabaseOrSkipAsync();
        await using var context = database.CreateContext();

        var migrator = context.Database.GetService<IMigrator>();

        await migrator.MigrateAsync("20260222173745_InitialContentBaseline");

        await context.Database.ExecuteSqlRawAsync("""
            CREATE TABLE IF NOT EXISTS admin_identity_users (
                "Id" uuid PRIMARY KEY,
                "Email" character varying(320) NOT NULL,
                "NormalizedEmail" character varying(320) NOT NULL,
                "DisplayName" character varying(120) NOT NULL,
                "PasswordHash" character varying(1024) NOT NULL,
                "AccessFailedCount" integer NOT NULL,
                "LockoutEndUtc" timestamp with time zone NULL,
                "CreatedAtUtc" timestamp with time zone NOT NULL
            );
            """);

        await context.Database.ExecuteSqlRawAsync("""
            INSERT INTO admin_identity_users (
                "Id", "Email", "NormalizedEmail", "DisplayName", "PasswordHash", "AccessFailedCount", "LockoutEndUtc", "CreatedAtUtc")
            VALUES (
                '11111111-1111-1111-1111-111111111111',
                'admin@toolnexus.local',
                'ADMIN@TOOLNEXUS.LOCAL',
                'Admin',
                'hash',
                0,
                NULL,
                NOW());
            """);

        await migrator.MigrateAsync("20260225214033_AddExecutionLedger");
        await context.Database.MigrateAsync();

        var existingCount = await context.Database.SqlQueryRaw<int>("SELECT COUNT(*) FROM admin_identity_users;").SingleAsync();
        Assert.Equal(1, existingCount);
        Assert.Empty(await context.Database.GetPendingMigrationsAsync());
    }

    [Fact]
    public async Task ExecutionLedgerMigration_PreexistingAdminIdentityUsersIndex_DoesNotFail()
    {
        await using var database = await CreatePostgresDatabaseOrSkipAsync();
        await using var context = database.CreateContext();

        var migrator = context.Database.GetService<IMigrator>();

        await migrator.MigrateAsync("20260222173745_InitialContentBaseline");

        await context.Database.ExecuteSqlRawAsync("""
            CREATE TABLE IF NOT EXISTS admin_identity_users (
                "Id" uuid PRIMARY KEY,
                "Email" character varying(320) NOT NULL,
                "NormalizedEmail" character varying(320) NOT NULL,
                "DisplayName" character varying(120) NOT NULL,
                "PasswordHash" character varying(1024) NOT NULL,
                "AccessFailedCount" integer NOT NULL,
                "LockoutEndUtc" timestamp with time zone NULL,
                "CreatedAtUtc" timestamp with time zone NOT NULL
            );
            CREATE UNIQUE INDEX IF NOT EXISTS "IX_admin_identity_users_NormalizedEmail"
            ON admin_identity_users ("NormalizedEmail");
            """);

        await migrator.MigrateAsync("20260225214033_AddExecutionLedger");
        await context.Database.MigrateAsync();

        Assert.Empty(await context.Database.GetPendingMigrationsAsync());
    }


    [Fact]
    public async Task GovernanceDecisionMigration_WithExecutionRunsId_BackfillsSuccessfully()
    {
        await using var database = await CreatePostgresDatabaseOrSkipAsync();
        await using var context = database.CreateContext();

        var migrator = context.Database.GetService<IMigrator>();
        await migrator.MigrateAsync("20260225214033_AddExecutionLedger");

        var runId = Guid.NewGuid();
        var snapshotId = Guid.NewGuid();

        await context.Database.ExecuteSqlAsync($"""
            INSERT INTO execution_runs (
                id, tool_id, executed_at_utc, success, duration_ms, error_type, payload_size,
                execution_mode, runtime_language, adapter_name, adapter_resolution_status,
                capability, authority, shadow_execution, correlation_id, tenant_id, trace_id)
            VALUES (
                '{runId}', 'tool-a', NOW(), TRUE, 12, NULL, 128,
                'sync', 'dotnet', 'default', 'resolved',
                'standard', 'Unified', FALSE, 'corr', 'tenant', 'trace');

            INSERT INTO execution_snapshots (
                id, execution_run_id, snapshot_id, authority, runtime_language,
                execution_capability, correlation_id, tenant_id, timestamp_utc, conformance_version, policy_snapshot_json)
            VALUES (
                '{snapshotId}', '{runId}', 'snap-1', 'Unified', 'dotnet',
                'standard', 'corr', 'tenant', NOW(), 'v1', jsonb_build_object());
            """);

        await migrator.MigrateAsync("20260225215625_20260313000000_AddGovernanceDecisionDomain");

        var count = await context.Database.SqlQueryRaw<int>("SELECT COUNT(*) FROM governance_decisions;").SingleAsync();
        Assert.Equal(1, count);
    }

    [Fact]
    public async Task GovernanceDecisionMigration_WithoutExecutionRunsIdColumn_DoesNotFailStartupMigration()
    {
        await using var database = await CreatePostgresDatabaseOrSkipAsync();
        await using var context = database.CreateContext();

        var migrator = context.Database.GetService<IMigrator>();
        await migrator.MigrateAsync("20260225214033_AddExecutionLedger");

        var runId = Guid.NewGuid();
        var snapshotId = Guid.NewGuid();

        await context.Database.ExecuteSqlAsync($"""
            INSERT INTO execution_runs (
                id, tool_id, executed_at_utc, success, duration_ms, error_type, payload_size,
                execution_mode, runtime_language, adapter_name, adapter_resolution_status,
                capability, authority, shadow_execution, correlation_id, tenant_id, trace_id)
            VALUES (
                '{runId}', 'tool-b', NOW(), TRUE, 12, NULL, 128,
                'sync', 'dotnet', 'default', 'resolved',
                'standard', 'Unified', FALSE, 'corr', 'tenant', 'trace');

            INSERT INTO execution_snapshots (
                id, execution_run_id, snapshot_id, authority, runtime_language,
                execution_capability, correlation_id, tenant_id, timestamp_utc, conformance_version, policy_snapshot_json)
            VALUES (
                '{snapshotId}', '{runId}', 'snap-2', 'Unified', 'dotnet',
                'standard', 'corr', 'tenant', NOW(), 'v1', jsonb_build_object());
            """);

        await context.Database.ExecuteSqlRawAsync("""
            ALTER TABLE execution_snapshots DROP CONSTRAINT IF EXISTS "FK_execution_snapshots_execution_runs_execution_run_id";
            ALTER TABLE execution_runs RENAME COLUMN id TO execution_run_id;
            """);

        await context.Database.MigrateAsync();
        Assert.Empty(await context.Database.GetPendingMigrationsAsync());
    }

    [Fact]
    public async Task InitialContentBaseline_CleanDatabase_MigratesSuccessfully()
    {
        await using var database = await CreatePostgresDatabaseOrSkipAsync();
        await using var context = database.CreateContext();

        var migrator = context.Database.GetService<IMigrator>();

        await migrator.MigrateAsync("20260222173745_InitialContentBaseline");

        Assert.DoesNotContain(
            "20260222173745_InitialContentBaseline",
            await context.Database.GetPendingMigrationsAsync());
    }

    [Fact]
    public async Task MigrationReplay_Twice_RemainsStable()
    {
        await using var database = await CreatePostgresDatabaseOrSkipAsync();
        await using var context = database.CreateContext();

        await context.Database.MigrateAsync();
        await context.Database.MigrateAsync();

        Assert.Empty(await context.Database.GetPendingMigrationsAsync());
    }

    private static async Task<TestDatabaseInstance> CreatePostgresDatabaseOrSkipAsync()
    {
        try
        {
            return await TestDatabaseInstance.CreateUnmigratedAsync(TestDatabaseProvider.PostgreSql);
        }
        catch (SkipException)
        {
            throw;
        }
        catch
        {
            throw SkipException.ForSkip("PostgreSQL integration test database is not configured for migration drift tests.");
        }
    }
}
