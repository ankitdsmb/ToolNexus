using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging.Abstractions;
using Microsoft.Extensions.Options;
using ToolNexus.Infrastructure.Content;
using ToolNexus.Infrastructure.Data;
using ToolNexus.Infrastructure.Options;
using Xunit;

namespace ToolNexus.Infrastructure.Tests.Migrations;

public sealed class PostgresToolExecutionEventsIdentityMigrationTests
{
    private const string HistoricalMigration = "20260225000000_AddToolExecutionEvents";
    private const string IdentitySensitiveMigration = "20260225214033_AddExecutionLedger";

    [Fact]
    public async Task CleanDatabase_MigrationPipeline_Succeeds()
    {
        await using var database = await CreatePostgresDatabaseOrSkipAsync();
        await using var context = database.CreateContext();

        await context.Database.MigrateAsync();

        Assert.Empty(await context.Database.GetPendingMigrationsAsync());
    }

    [Fact]
    public async Task ToolExecutionEventsId_PreexistingIdentity_MigrationSucceeds()
    {
        await using var database = await CreatePostgresDatabaseOrSkipAsync();
        await using var context = database.CreateContext();
        var migrator = context.Database.GetService<IMigrator>();

        await migrator.MigrateAsync(HistoricalMigration);

        await context.Database.ExecuteSqlRawAsync("""
            DO $$
            BEGIN
                IF EXISTS (
                    SELECT 1
                    FROM information_schema.columns
                    WHERE table_schema = current_schema()
                      AND table_name = 'ToolExecutionEvents'
                      AND column_name = 'Id'
                      AND is_identity = 'NO')
                THEN
                    ALTER TABLE "ToolExecutionEvents"
                        ALTER COLUMN "Id" ADD GENERATED BY DEFAULT AS IDENTITY;
                END IF;
            END $$;
            """);

        await migrator.MigrateAsync(IdentitySensitiveMigration);
        await context.Database.MigrateAsync();

        Assert.Empty(await context.Database.GetPendingMigrationsAsync());
    }

    [Fact]
    public async Task MigrationReplay_Twice_DoesNotFail()
    {
        await using var database = await CreatePostgresDatabaseOrSkipAsync();
        await using var context = database.CreateContext();

        await context.Database.MigrateAsync();
        await context.Database.MigrateAsync();

        Assert.Empty(await context.Database.GetPendingMigrationsAsync());
    }

    [Fact]
    public async Task StartupInitialization_WithHistoricalSchema_Completes()
    {
        await using var database = await CreatePostgresDatabaseOrSkipAsync();
        await using var context = database.CreateContext();
        var migrator = context.Database.GetService<IMigrator>();

        await migrator.MigrateAsync(HistoricalMigration);

        var connectionString = context.Database.GetConnectionString();
        Assert.False(string.IsNullOrWhiteSpace(connectionString));

        var services = new ServiceCollection();
        services.AddDbContext<ToolNexusContentDbContext>(options => options.UseNpgsql(connectionString));
        services.AddDbContext<ToolNexusIdentityDbContext>(options => options.UseNpgsql(connectionString));

        await using var provider = services.BuildServiceProvider();

        var state = new DatabaseInitializationState();
        var service = new DatabaseInitializationHostedService(
            provider,
            Microsoft.Extensions.Options.Options.Create(new DatabaseInitializationOptions { RunMigrationOnStartup = true }),
            state,
            NullLogger<DatabaseInitializationHostedService>.Instance);

        await service.ExecuteAsync(CancellationToken.None);

        Assert.False(state.HasFailed);
    }

    private static async Task<TestDatabaseInstance> CreatePostgresDatabaseOrSkipAsync()
    {
        try
        {
            return await TestDatabaseInstance.CreateUnmigratedAsync(TestDatabaseProvider.PostgreSql);
        }
        catch (Exception ex)
        {
            throw new InvalidOperationException("PostgreSQL integration test database unavailable.", ex);
        }
    }
}
